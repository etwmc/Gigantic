%option noyywrap
%option case-insensitive
%option reentrant
%option bison-bridge
%option header-file="Grammar.yy.h"

%{
    #import "Grammar.h"
    #import "Grammar.tab.h"
    #import <iostream>
    using namespace std;
    
    int getIndex(const char *indexBuffer, int offset);
    void toLowerString(char *s);
    extern int yyerror(void *scanner, const char *s);
    
    #define YYDEBUG 1
    bool charReachEnd(char c) {
        return (c=='\r'||c=='\n'||c==' ');
    }
%}

/*
 * The following is symbolic recogniztion for different type of word, which the identifiers are generated by the extensions, and should be pass in a [extensionID], type, [objID] format in the result
 */
index [0-9]+
adjective   {index}_a{index}
verb        {index}_v{index}
person      {index}_p{index}
location    {index}_l{index}
instance    {index}_i{index}
noun        {index}_n{index}
number      {index}_d{index}

/*
 * The following are manually hard-coded, which is higly tied to the structure of the system, which should use Gigantic Central to recoginze the words, and mark as common phase, which should never be define in the extension
 */

pronoun             he|she|her1|it|they|we|i|you|this|that|everyone|anyone|one|me
ownershipPronoun    his|her|its|their|our|my|your
questionWord        (what)|(where)|(who)|(when)|(how)|(which)
do                  (do)|(does)|(did)|(done)
be                  (is)|(are)|(am)|(was)|(were)|(been)
preposition         (on)|(in)|(to)|(by)|(for)|(with)|(at)|(from)
objRelationshipPrepo of
greeting            (hi)|(hello)|(hey)|(good" "morning)|(good" "afternoon)|(good" "evening)
parting             (bye)|(goodbye)|(good" "bye)|(goodbye)|(good" "night)
gratitude           (thanks)[:lower:]*|(thank" "you)[:lower:]*

article             a|an|the

%%
{article} {
    //Skip article
}

{objRelationshipPrepo} {
    *yylval_param = new word(-1, phaseType_preposition, yytext);
    return objPREPO;
}

{adjective}|{verb}|{person}|{location}|{noun}|{instance} {
    char *endPtr = nullptr;
    long objID = strtol(yytext, &endPtr, 10);
    int index = getIndex(endPtr, 2);
    switch (*(endPtr+1)) {
        case 'a':
            *yylval_param = new word(objID, phaseType_adjective, index);
            return ADJ;
        case 'v':
            *yylval_param = new word(objID, phaseType_verb, index);
            return VERB;
        case 'p':
            *yylval_param = new word(objID, phaseType_person, index);
            return NOUN;
        case 'i':
            *yylval_param = new word(objID, phaseType_instance, index);
            return NOUN;
        case 'l':
            *yylval_param = new word(objID, phaseType_location, index);
            return NOUN;
        case 'n':
            *yylval_param = new word(objID, phaseType_noun, index);
            return NOUN;
        case 'd':
            *yylval_param = new word(objID, phaseType_digit, index);
            return DIGIT;
    }
}

{pronoun} {
    *yylval_param = new word(-1, phaseType_pronoun, yytext);
    return PRONOUN;
}
{ownershipPronoun} {
    *yylval_param = new word(-1, phaseType_pronoun, yytext);
    return OWNER;
}
{questionWord} {
    *yylval_param = new word(-1, phaseType_questionWord, yytext);
    if (strncasecmp("what", yytext, 4) == 0) return WHAT;
    if (strncasecmp("where", yytext, 5) == 0) return WHERE;
    if (strncasecmp("who", yytext, 3) == 0) return WHO;
    if (strncasecmp("when", yytext, 4) == 0) return WHEN;
    if (strncasecmp("how", yytext, 3) == 0) return HOW;
    if (strncasecmp("which", yytext, 5) == 0) return WHICH;
    return FAIL;
}
{preposition} {
    *yylval_param = new word(-1, phaseType_preposition, yytext);
    return PREPO;
}
{greeting} {
    *yylval_param = new word(-1, phaseType_exclamation_greet, yytext);
    return EXCLAMATION;
}
{parting} {
    *yylval_param = new word(-1, phaseType_exclamation_parting, yytext);
    return EXCLAMATION;
}
{gratitude} {
    *yylval_param = new word(-1, phaseType_exclamation_gratitude, yytext);
    return EXCLAMATION;
}
{do} {
    *yylval_param = new word(-1, phaseType_verb, "do");
    return DO;
}
{be} {
    *yylval_param = new word(-1, phaseType_verb, "be");
    return BE;
}
and { return _and; }
or { return _or; }
\n              { return *yytext; }
[ \t\r] {}
. {
    //If reach this point, the term is not recognizable
    int i = 2;
    do {
        yyless(i++);
    } while(!charReachEnd(yytext[i-2]));
    cout << "Unknown term: " << yytext << endl;
    /*
     * FAIL is a symbol left ununsed in the grammar definition, which automatically trigger a syntax error in yacc once returned. 
     */
    return FAIL;
}
if {
    return IF;
}
%%

int getIndex(const char *indexBuffer, int offset) {
    const char *ptr = indexBuffer+offset;
    return atoi(ptr);
}